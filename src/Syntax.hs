{-# LANGUAGE GADTs #-}

module Syntax (
    Literal (LUnit, LBool, LInt, LFloat),
    UnaryOp (Not, Neg, FNeg),
    RelationBinOp (Eq, Le, Ge, Ne, Lt, Gt),
    IntBinOp (Add, Sub, Mul, Div),
    FloatBinOp (FAdd, FSub, FMul, FDiv),
    BinaryOp (RelationOp, IntOp, FloatOp),
    Ident (UserDefined, CompilerGenerated, ExternalIdent),
    Pattern (PUnit, PVar, PRec, PTuple),
    ParsedExpr (PGuard, pExp),
    ResolvedExpr (RGuard, rExp),
    RawIdent (RawIdent),
    TypedState (TypedState, getType, getPosition),
    KExpr,
    TypedExpr (TGuard, tExp),
    Expr (Const, Unary, Binary, If, Let, Var, App, Tuple, ArrayCreate, Get, Put),
    getExprState,
    visitExprM,
) where

import Data.Text (Text)
import Text.Megaparsec.Pos (SourcePos)
import Typing (Ty)

data Literal
    = LUnit
    | LBool Bool
    | LInt Int
    | LFloat Float
    deriving (Show, Eq)

data UnaryOp
    = Not
    | Neg
    | FNeg
    deriving (Show, Eq)

data RelationBinOp = Eq | Le | Ge | Ne | Lt | Gt deriving (Show, Eq)
data IntBinOp = Add | Sub | Mul | Div deriving (Show, Eq)
data FloatBinOp = FAdd | FSub | FMul | FDiv deriving (Show, Eq)
data BinaryOp
    = RelationOp RelationBinOp
    | IntOp IntBinOp
    | FloatOp FloatBinOp
    deriving (Show, Eq)

data RawIdent
    = RawIdent SourcePos Text
    deriving (Show, Eq)

data Ident
    = -- | An identifier after name resolution.
      UserDefined SourcePos Text
    | -- | An identifier generated by the compiler.
      CompilerGenerated Text
    | -- | An identifier that is used to refer to an external item.
      ExternalIdent Text
    deriving (Show, Eq)

data Pattern identTy
    = PUnit
    | PVar identTy
    | PRec identTy [identTy]
    | PTuple [identTy]
    deriving (Show, Eq)

{- | The type of an expression after parsing.
PGuard is used for avoiding invalid recursive type definition.
-}
newtype ParsedExpr = PGuard {pExp :: Expr SourcePos RawIdent ParsedExpr}
    deriving (Show, Eq)

{- | The type of an expression after name resolution.
RGuard is used for avoiding invalid recursive type definition.
-}
newtype ResolvedExpr = RGuard {rExp :: Expr SourcePos Ident ResolvedExpr}
    deriving (Show, Eq)

data TypedState = TypedState {getType :: Ty, getPosition :: SourcePos}
    deriving (Show, Eq)

-- | The type of an expression after type inference.
newtype TypedExpr = TGuard {tExp :: Expr TypedState Ident TypedExpr}
    deriving (Show, Eq)

type KExpr = Expr SourcePos Ident Ident

data Expr state identTy operandTy where
    Const :: state -> Literal -> Expr state a b
    Unary :: state -> UnaryOp -> operandTy -> Expr state a operandTy
    Binary :: state -> BinaryOp -> operandTy -> operandTy -> Expr state a operandTy
    If :: state -> operandTy -> Expr state identTy operandTy -> Expr state identTy operandTy -> Expr state identTy operandTy
    Let :: state -> Pattern identTy -> Expr state identTy operandTy -> Expr state identTy operandTy -> Expr state identTy operandTy
    Var :: state -> identTy -> Expr state identTy b
    App :: state -> operandTy -> [operandTy] -> Expr state a operandTy
    Tuple :: state -> [operandTy] -> Expr state a operandTy
    ArrayCreate :: state -> operandTy -> operandTy -> Expr state a operandTy
    Get :: state -> operandTy -> operandTy -> Expr state a operandTy
    Put :: state -> operandTy -> operandTy -> operandTy -> Expr state a operandTy
    deriving (Show, Eq)

getExprState :: Expr state identTy operandTy -> state
getExprState (Const state _) = state
getExprState (Unary state _ _) = state
getExprState (Binary state _ _ _) = state
getExprState (If state _ _ _) = state
getExprState (Let state _ _ _) = state
getExprState (Var state _) = state
getExprState (App state _ _) = state
getExprState (Tuple state _) = state
getExprState (ArrayCreate state _ _) = state
getExprState (Get state _ _) = state
getExprState (Put state _ _ _) = state

visitExprM ::
    (Monad m) =>
    (state -> m state') ->
    (identTy -> m identTy') ->
    (operandTy -> m operandTy') ->
    Expr state identTy operandTy ->
    m (Expr state' identTy' operandTy')
visitExprM fState _ _ (Const state lit) = do
    state' <- fState state
    pure $ Const state' lit
visitExprM fState _ fOperand (Unary state op operand) = do
    state' <- fState state
    operand' <- fOperand operand
    pure $ Unary state' op operand'
visitExprM fState _ fOperand (Binary state op lhs rhs) = do
    state' <- fState state
    lhs' <- fOperand lhs
    rhs' <- fOperand rhs
    pure $ Binary state' op lhs' rhs'
visitExprM fState fIdent fOperand (If state cond thenE elseE) = do
    state' <- fState state
    cond' <- fOperand cond
    thenE' <- visitExprM fState fIdent fOperand thenE
    elseE' <- visitExprM fState fIdent fOperand elseE
    pure $ If state' cond' thenE' elseE'
visitExprM fState fIdent fOperand (Let state pat expr body) = do
    state' <- fState state
    expr' <- visitExprM fState fIdent fOperand expr
    body' <- visitExprM fState fIdent fOperand body
    pat' <- visitPatternM fIdent pat
    pure $ Let state' pat' expr' body'
  where
    visitPatternM :: (Monad m) => (identTy -> m identTy') -> Pattern identTy -> m (Pattern identTy')
    visitPatternM _ (PUnit) = pure PUnit
    visitPatternM fIdent' (PVar ident) = PVar <$> fIdent' ident
    visitPatternM fIdent' (PRec ident idents) = PRec <$> fIdent' ident <*> mapM fIdent' idents
    visitPatternM fIdent' (PTuple idents) = PTuple <$> mapM fIdent' idents
visitExprM fState fIdent _ (Var state ident) = do
    state' <- fState state
    ident' <- fIdent ident
    pure $ Var state' ident'
visitExprM fState _ fOperand (App state func args) = do
    state' <- fState state
    func' <- fOperand func
    args' <- mapM fOperand args
    pure $ App state' func' args'
visitExprM fState _ fOperand (Tuple state values) = do
    state' <- fState state
    values' <- mapM fOperand values
    pure $ Tuple state' values'
visitExprM fState _ fOperand (ArrayCreate state size value) = do
    state' <- fState state
    size' <- fOperand size
    value' <- fOperand value
    pure $ ArrayCreate state' size' value'
visitExprM fState _ fOperand (Get state array index) = do
    state' <- fState state
    array' <- fOperand array
    index' <- fOperand index
    pure $ Get state' array' index'
visitExprM fState _ fOperand (Put state array index value) = do
    state' <- fState state
    array' <- fOperand array
    index' <- fOperand index
    value' <- fOperand value
    pure $ Put state' array' index' value'
