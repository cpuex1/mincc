{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}

module Syntax (
    Literal (LUnit, LBool, LInt, LFloat),
    getLiteralType,
    UnaryOp (Not, Neg, FNeg),
    RelationBinOp (Eq, Ne, Lt, Ge),
    IntBinOp (Add, Sub, Mul, Div),
    FloatBinOp (FAdd, FSub, FMul, FDiv),
    BinaryOp (RelationOp, IntOp, FloatOp),
    Ident (Entry, UserDefined, CompilerGenerated, ExternalIdent),
    Pattern (PUnit, PVar, PRec, PTuple),
    Cond (..),
    RawIdent (RawIdent),
    TypedState (TypedState, getType, getLoc),
    fromSourcePos,
    identLoc,
    Loc (Loc, locFileName, locLine, locColumn),
    dummyLoc,
    ParsedExpr,
    TypedExpr,
    ResolvedExpr,
    KExpr,
    ClosureExpr,
    Function (Function, funcName, isDirect, freeVars, boundedArgs, funcBody),
    ExprKind (..),
    Expr (..),
    getExprState,
    subst,
    visitExprM,
) where

import Control.Monad.Identity (Identity (runIdentity))
import Data.Kind (Type)
import Data.Text (Text, intercalate, pack, unwords)
import Display (Display (display), DisplayI (displayI), insertIndent)
import Numeric (showFFloat)
import Text.Megaparsec.Pos (SourcePos, sourceColumn, sourceLine, sourceName, unPos)
import Typing (Ty, TypeKind (TBool, TFloat, TInt, TUnit))
import Prelude hiding (unwords)

data Literal
    = LUnit
    | LBool Bool
    | LInt Int
    | LFloat Float
    deriving (Show, Eq, Ord)

instance Display Literal where
    display LUnit = "()"
    display (LBool True) = "true"
    display (LBool False) = "false"
    display (LInt n) = pack $ show n
    display (LFloat f) = pack $ showFFloat Nothing f ""

getLiteralType :: Literal -> Ty
getLiteralType LUnit = TUnit
getLiteralType (LBool _) = TBool
getLiteralType (LInt _) = TInt
getLiteralType (LFloat _) = TFloat

data UnaryOp
    = Not
    | Neg
    | FNeg
    deriving (Show, Eq, Ord)

instance Display UnaryOp where
    display Not = "not"
    display Neg = "-"
    display FNeg = "-."

data RelationBinOp = Eq | Ne | Lt | Ge deriving (Show, Eq, Ord)
data IntBinOp = Add | Sub | Mul | Div deriving (Show, Eq, Ord)
data FloatBinOp = FAdd | FSub | FMul | FDiv deriving (Show, Eq, Ord)
data BinaryOp
    = RelationOp RelationBinOp
    | IntOp IntBinOp
    | FloatOp FloatBinOp
    deriving (Show, Eq, Ord)

instance Display BinaryOp where
    display (RelationOp Eq) = "="
    display (RelationOp Ge) = ">="
    display (RelationOp Ne) = "<>"
    display (RelationOp Lt) = "<"
    display (IntOp Add) = "+"
    display (IntOp Sub) = "-"
    display (IntOp Mul) = "*"
    display (IntOp Div) = "/"
    display (FloatOp FAdd) = "+."
    display (FloatOp FSub) = "-."
    display (FloatOp FMul) = "*."
    display (FloatOp FDiv) = "/."

data RawIdent
    = RawIdent Loc Text
    deriving (Show, Eq)

instance Display RawIdent where
    display (RawIdent _ ident) = ident

data Ident
    = -- | The entry of the program.
      Entry Loc
    | -- | An identifier after name resolution.
      UserDefined Loc Text
    | -- | An identifier generated by the compiler.
      CompilerGenerated Int
    | -- | An identifier that is used to refer to an external item.
      ExternalIdent Text
    deriving (Show, Eq, Ord)

instance DisplayI Ident where
    displayI _ (Entry _) = "__entry"
    displayI _ (UserDefined pos ident) =
        "__"
            <> ident
            <> "_"
            <> (pack . show . locLine) pos
            <> "_"
            <> (pack . show . locColumn) pos
    displayI _ (CompilerGenerated ident) =
        "__gen_" <> pack (show ident)
    displayI _ (ExternalIdent ident) =
        "__ext_" <> ident

instance Display Ident where
    display = displayI 0

identLoc :: Ident -> Loc
identLoc (Entry pos) = pos
identLoc (UserDefined pos _) = pos
identLoc (CompilerGenerated _) = Loc "generated" 0 0
identLoc (ExternalIdent _) = Loc "external" 0 0

-- | Pattern matching used in let-expressions.
data Pattern identTy
    = PUnit
    | PVar identTy
    | PRec identTy [identTy]
    | PTuple [identTy]
    deriving (Show, Eq, Ord)

-- | A condition of an if-expression.
data Cond operandTy (allowCompTy :: Bool) where
    CIdentity :: operandTy -> Cond operandTy allowCompTy
    CComp :: RelationBinOp -> operandTy -> operandTy -> Cond operandTy True

deriving instance
    (Show operandTy) =>
    Show (Cond operandTy a)
deriving instance
    (Eq operandTy) =>
    Eq (Cond operandTy a)

deriving instance
    (Ord operandTy) =>
    Ord (Cond operandTy a)

data Loc = Loc {locFileName :: Text, locLine :: Int, locColumn :: Int}
    deriving (Show, Eq, Ord)

instance Display Loc where
    display loc =
        locFileName loc
            <> ":"
            <> pack (show (locLine loc))
            <> ":"
            <> pack (show (locColumn loc))

fromSourcePos :: SourcePos -> Loc
fromSourcePos pos = Loc (pack (sourceName pos)) (unPos (sourceLine pos)) (unPos (sourceColumn pos))

dummyLoc :: Loc
dummyLoc = Loc "__dummy" 0 0

data TypedState = TypedState {getType :: Ty, getLoc :: Loc}
    deriving (Show, Eq, Ord)

instance Display TypedState where
    display (TypedState ty _) = ": " <> display ty

data Function = Function
    { funcState :: TypedState
    , isDirect :: Bool
    , funcName :: Ident
    , freeVars :: [Ident]
    , boundedArgs :: [Ident]
    , funcBody :: ClosureExpr
    }
    deriving (Show, Eq)

instance DisplayI Function where
    displayI depth func =
        insertIndent depth
            <> display (funcName func)
            <> "@"
            <> (if isDirect func then "direct" else "closure")
            <> " {"
            <> unwords (map display (freeVars func))
            <> "} "
            <> unwords (map display (boundedArgs func))
            <> ":\n"
            <> insertIndent (depth + 1)
            <> displayI (depth + 1) (funcBody func)

instance Display Function where
    display = displayI 0

-- | The type of an expression.
class ExprKind ty where
    type StateTy ty :: Type
    type IdentTy ty :: Type
    type OperandTy ty :: Type
    type AllowBranch ty :: Bool
    type AllowLoop ty :: Bool
    type AllowClosure ty :: Bool

data ParsedExprKind

instance ExprKind ParsedExprKind where
    type StateTy ParsedExprKind = Loc
    type IdentTy ParsedExprKind = RawIdent
    type OperandTy ParsedExprKind = ParsedExpr
    type AllowBranch ParsedExprKind = False
    type AllowLoop ParsedExprKind = False
    type AllowClosure ParsedExprKind = False

{- | The type of an expression after parsing.
PGuard is used for avoiding invalid recursive type definition.
-}
type ParsedExpr = Expr ParsedExprKind

data ResolvedExprKind

instance ExprKind ResolvedExprKind where
    type StateTy ResolvedExprKind = Loc
    type IdentTy ResolvedExprKind = Ident
    type OperandTy ResolvedExprKind = ResolvedExpr
    type AllowBranch ResolvedExprKind = False
    type AllowLoop ResolvedExprKind = False
    type AllowClosure ResolvedExprKind = False

{- | The type of an expression after name resolution.
RGuard is used for avoiding invalid recursive type definition.
-}
type ResolvedExpr = Expr ResolvedExprKind

data TypedExprKind

instance ExprKind TypedExprKind where
    type StateTy TypedExprKind = TypedState
    type IdentTy TypedExprKind = Ident
    type OperandTy TypedExprKind = TypedExpr
    type AllowBranch TypedExprKind = False
    type AllowLoop TypedExprKind = False
    type AllowClosure TypedExprKind = False

-- | The type of an expression after type inference.
type TypedExpr = Expr TypedExprKind

data KExprKind

instance ExprKind KExprKind where
    type StateTy KExprKind = TypedState
    type IdentTy KExprKind = Ident
    type OperandTy KExprKind = Ident
    type AllowBranch KExprKind = True
    type AllowLoop KExprKind = True
    type AllowClosure KExprKind = False

-- | The type of an expression after K-normalization.
type KExpr = Expr KExprKind

data ClosureExprKind

instance ExprKind ClosureExprKind where
    type StateTy ClosureExprKind = TypedState
    type IdentTy ClosureExprKind = Ident
    type OperandTy ClosureExprKind = Ident
    type AllowBranch ClosureExprKind = True
    type AllowLoop ClosureExprKind = True
    type AllowClosure ClosureExprKind = True

-- | The type of an expression after introducing closures.
type ClosureExpr = Expr ClosureExprKind

-- | An expression.
data Expr kind where
    Const ::
        StateTy kind ->
        Literal ->
        Expr kind
    Unary ::
        StateTy kind ->
        UnaryOp ->
        OperandTy kind ->
        Expr kind
    Binary ::
        StateTy kind ->
        BinaryOp ->
        OperandTy kind ->
        OperandTy kind ->
        Expr kind
    If ::
        StateTy kind ->
        Cond (OperandTy kind) (AllowBranch kind) ->
        Expr kind ->
        Expr kind ->
        Expr kind
    Let ::
        StateTy kind ->
        Pattern (IdentTy kind) ->
        Expr kind ->
        Expr kind ->
        Expr kind
    Var ::
        StateTy kind ->
        IdentTy kind ->
        Expr kind
    App ::
        (AllowClosure kind ~ False) =>
        StateTy kind ->
        OperandTy kind ->
        [OperandTy kind] ->
        Expr kind
    Tuple ::
        StateTy kind ->
        [OperandTy kind] ->
        Expr kind
    ArrayCreate ::
        StateTy kind ->
        OperandTy kind ->
        OperandTy kind ->
        Expr kind
    Get ::
        StateTy kind ->
        OperandTy kind ->
        OperandTy kind ->
        Expr kind
    Put ::
        StateTy kind ->
        OperandTy kind ->
        OperandTy kind ->
        OperandTy kind ->
        Expr kind
    Loop ::
        (AllowLoop kind ~ True) =>
        StateTy kind ->
        [IdentTy kind] ->
        [IdentTy kind] ->
        Expr kind ->
        Expr kind
    Continue ::
        (AllowLoop kind ~ True) =>
        StateTy kind ->
        [IdentTy kind] ->
        Expr kind
    MakeClosure ::
        (AllowClosure kind ~ True) =>
        StateTy kind ->
        IdentTy kind ->
        [OperandTy kind] ->
        Expr kind
    ClosureApp ::
        (AllowClosure kind ~ True) =>
        StateTy kind ->
        IdentTy kind ->
        [OperandTy kind] ->
        Expr kind
    DirectApp ::
        (AllowClosure kind ~ True) =>
        StateTy kind ->
        IdentTy kind ->
        [OperandTy kind] ->
        Expr kind

deriving instance (Show (StateTy kind), Show (IdentTy kind), Show (OperandTy kind)) => Show (Expr kind)
deriving instance (Eq (StateTy kind), Eq (IdentTy kind), Eq (OperandTy kind)) => Eq (Expr kind)
deriving instance (Ord (StateTy kind), Ord (IdentTy kind), Ord (OperandTy kind)) => Ord (Expr kind)

instance (Display (StateTy kind), Display (IdentTy kind), DisplayI (OperandTy kind)) => DisplayI (Expr kind) where
    displayI indentDepth expression = withoutState expression indentDepth <> " (* " <> display (getExprState expression) <> " *)"
      where
        withoutState :: (Display (StateTy kind), Display (IdentTy kind), DisplayI (OperandTy kind)) => Expr kind -> Int -> Text
        withoutState (Const _ lit) _ = display lit
        withoutState (Unary _ op expr) depth =
            "(" <> display op <> " " <> displayI depth expr <> ")"
        withoutState (Binary _ op expr1 expr2) depth =
            "(" <> displayI depth expr1 <> " " <> display op <> " " <> displayI depth expr2 <> ")"
        withoutState (If _ (CIdentity cond) thenExpr elseExpr) depth =
            "(if "
                <> displayI depth cond
                <> " then\n"
                <> insertIndent (depth + 1)
                <> displayI (depth + 1) thenExpr
                <> "\n"
                <> insertIndent depth
                <> "else\n"
                <> insertIndent (depth + 1)
                <> displayI (depth + 1) elseExpr
                <> ")"
        withoutState (If _ (CComp op lhs rhs) thenExpr elseExpr) depth =
            "(if "
                <> "("
                <> displayI depth lhs
                <> " "
                <> display (RelationOp op)
                <> " "
                <> displayI depth rhs
                <> ")"
                <> " then\n"
                <> insertIndent (depth + 1)
                <> displayI (depth + 1) thenExpr
                <> "\n"
                <> insertIndent depth
                <> "else\n"
                <> insertIndent (depth + 1)
                <> displayI (depth + 1) elseExpr
                <> ")"
        withoutState (Let _ PUnit value body) depth =
            "(let () = "
                <> displayI depth value
                <> " in\n"
                <> insertIndent depth
                <> displayI depth body
                <> ")"
        withoutState (Let _ (PVar v) value body) depth =
            "(let "
                <> display v
                <> " = "
                <> displayI depth value
                <> " in\n"
                <> insertIndent depth
                <> displayI depth body
                <> ")"
        withoutState (Let _ (PRec f args) value body) depth =
            "(let rec "
                <> display f
                <> " "
                <> Data.Text.unwords (Prelude.map display args)
                <> " =\n"
                <> insertIndent (depth + 1)
                <> displayI (depth + 1) value
                <> " in\n"
                <> insertIndent depth
                <> displayI depth body
                <> ")"
        withoutState (Let _ (PTuple values) value body) depth =
            "(let ("
                <> Data.Text.unwords (Prelude.map display values)
                <> ") = "
                <> displayI depth value
                <> " in\n"
                <> insertIndent depth
                <> displayI depth body
                <> ")"
        withoutState (App _ func args) depth =
            "(" <> displayI depth func <> " " <> Data.Text.unwords (Prelude.map (displayI depth) args) <> ")"
        withoutState (Tuple _ values) depth =
            "(" <> intercalate ", " (Prelude.map (displayI depth) values) <> ")"
        withoutState (ArrayCreate _ size initVal) depth =
            "(Array.create " <> displayI depth size <> " " <> displayI depth initVal <> ")"
        withoutState (Get _ array idx) depth =
            "(" <> displayI depth array <> ".(" <> displayI depth idx <> "))"
        withoutState (Put _ array idx value) depth =
            "(" <> displayI depth array <> ".(" <> displayI depth idx <> ") <- " <> displayI depth value <> ")"
        withoutState (Var _ v) _ = display v
        withoutState (Loop _ args values body) depth =
            "(loop "
                <> Data.Text.intercalate ", " (Prelude.zipWith (\a v -> display a <> " := " <> display v) args values)
                <> "\n"
                <> insertIndent (depth + 1)
                <> displayI (depth + 1) body
                <> ")"
        withoutState (Continue _ values) _ = "continue " <> Data.Text.unwords (Prelude.map display values)
        withoutState (MakeClosure _ ident args) depth =
            "<" <> display ident <> ", " <> Data.Text.unwords (Prelude.map (displayI depth) args) <> ">"
        withoutState (ClosureApp _ closure args) depth =
            "(" <> display closure <> " @ " <> Data.Text.unwords (Prelude.map (displayI depth) args) <> ")"
        withoutState (DirectApp _ func args) depth =
            "(" <> display func <> " " <> Data.Text.unwords (Prelude.map (displayI depth) args) <> ")"

instance (Display (StateTy kind), Display (IdentTy kind), DisplayI (OperandTy kind)) => Display (Expr kind) where
    display = displayI 0

getExprState :: Expr kind -> StateTy kind
getExprState (Const state _) = state
getExprState (Unary state _ _) = state
getExprState (Binary state _ _ _) = state
getExprState (If state _ _ _) = state
getExprState (Let state _ _ _) = state
getExprState (Var state _) = state
getExprState (App state _ _) = state
getExprState (Tuple state _) = state
getExprState (ArrayCreate state _ _) = state
getExprState (Get state _ _) = state
getExprState (Put state _ _ _) = state
getExprState (Loop state _ _ _) = state
getExprState (Continue state _) = state
getExprState (MakeClosure state _ _) = state
getExprState (ClosureApp state _ _) = state
getExprState (DirectApp state _ _) = state

-- | Substitute identifiers and operands. The identifiers should be unique.
subst ::
    (IdentTy kind ~ OperandTy kind, Eq (IdentTy kind)) =>
    IdentTy kind ->
    IdentTy kind ->
    Expr kind ->
    Expr kind
subst before after expr =
    runIdentity $
        visitExprM
            pure
            (\ident -> pure $ if ident == before then after else ident)
            (\operand -> pure $ if operand == before then after else operand)
            expr

visitExprM ::
    ( Monad m
    , AllowBranch a ~ AllowBranch b
    , AllowLoop a ~ AllowLoop b
    , AllowClosure a ~ AllowClosure b
    ) =>
    (StateTy a -> m (StateTy b)) ->
    (IdentTy a -> m (IdentTy b)) ->
    (OperandTy a -> m (OperandTy b)) ->
    Expr a ->
    m (Expr b)
visitExprM fState _ _ (Const state lit) = do
    state' <- fState state
    pure $ Const state' lit
visitExprM fState _ fOperand (Unary state op operand) = do
    state' <- fState state
    operand' <- fOperand operand
    pure $ Unary state' op operand'
visitExprM fState _ fOperand (Binary state op lhs rhs) = do
    state' <- fState state
    lhs' <- fOperand lhs
    rhs' <- fOperand rhs
    pure $ Binary state' op lhs' rhs'
visitExprM fState fIdent fOperand (If state (CIdentity cond) thenE elseE) = do
    state' <- fState state
    cond' <- fOperand cond
    thenE' <- visitExprM fState fIdent fOperand thenE
    elseE' <- visitExprM fState fIdent fOperand elseE
    pure $ If state' (CIdentity cond') thenE' elseE'
visitExprM fState fIdent fOperand (If state (CComp op lhs rhs) thenE elseE) = do
    state' <- fState state
    lhs' <- fOperand lhs
    rhs' <- fOperand rhs
    thenE' <- visitExprM fState fIdent fOperand thenE
    elseE' <- visitExprM fState fIdent fOperand elseE
    pure $ If state' (CComp op lhs' rhs') thenE' elseE'
visitExprM fState fIdent fOperand (Let state pat expr body) = do
    state' <- fState state
    expr' <- visitExprM fState fIdent fOperand expr
    body' <- visitExprM fState fIdent fOperand body
    pat' <- visitPatternM fIdent pat
    pure $ Let state' pat' expr' body'
  where
    visitPatternM :: (Monad m) => (identTy -> m identTy') -> Pattern identTy -> m (Pattern identTy')
    visitPatternM _ PUnit = pure PUnit
    visitPatternM fIdent' (PVar ident) = PVar <$> fIdent' ident
    visitPatternM fIdent' (PRec ident idents) = PRec <$> fIdent' ident <*> mapM fIdent' idents
    visitPatternM fIdent' (PTuple idents) = PTuple <$> mapM fIdent' idents
visitExprM fState fIdent _ (Var state ident) = do
    state' <- fState state
    ident' <- fIdent ident
    pure $ Var state' ident'
visitExprM fState _ fOperand (App state func args) = do
    state' <- fState state
    func' <- fOperand func
    args' <- mapM fOperand args
    pure $ App state' func' args'
visitExprM fState _ fOperand (Tuple state values) = do
    state' <- fState state
    values' <- mapM fOperand values
    pure $ Tuple state' values'
visitExprM fState _ fOperand (ArrayCreate state size value) = do
    state' <- fState state
    size' <- fOperand size
    value' <- fOperand value
    pure $ ArrayCreate state' size' value'
visitExprM fState _ fOperand (Get state array index) = do
    state' <- fState state
    array' <- fOperand array
    index' <- fOperand index
    pure $ Get state' array' index'
visitExprM fState _ fOperand (Put state array index value) = do
    state' <- fState state
    array' <- fOperand array
    index' <- fOperand index
    value' <- fOperand value
    pure $ Put state' array' index' value'
visitExprM fState fIdent fOperand (Loop state args vars body) = do
    state' <- fState state
    args' <- mapM fIdent args
    vars' <- mapM fIdent vars
    body' <- visitExprM fState fIdent fOperand body
    pure $ Loop state' args' vars' body'
visitExprM fState fIdent _ (Continue state args) = do
    state' <- fState state
    args' <- mapM fIdent args
    pure $ Continue state' args'
visitExprM fState fIdent fOperand (MakeClosure state ident args) = do
    state' <- fState state
    ident' <- fIdent ident
    args' <- mapM fOperand args
    pure $ MakeClosure state' ident' args'
visitExprM fState fIdent fOperand (ClosureApp state ident args) = do
    state' <- fState state
    ident' <- fIdent ident
    args' <- mapM fOperand args
    pure $ ClosureApp state' ident' args'
visitExprM fState fIdent fOperand (DirectApp state ident args) = do
    state' <- fState state
    ident' <- fIdent ident
    args' <- mapM fOperand args
    pure $ DirectApp state' ident' args'
