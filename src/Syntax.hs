{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}

module Syntax (
    Literal (LUnit, LBool, LInt, LFloat),
    getLiteralType,
    UnaryOp (Not, Neg, FNeg),
    RelationBinOp (Eq, Ne, Lt, Ge),
    IntBinOp (Add, Sub, Mul, Div),
    FloatBinOp (FAdd, FSub, FMul, FDiv),
    BinaryOp (RelationOp, IntOp, FloatOp),
    Ident (Entry, UserDefined, CompilerGenerated, ExternalIdent),
    Pattern (PUnit, PVar, PRec, PTuple),
    Cond (..),
    RawIdent (RawIdent),
    TypedState (TypedState, getType, getLoc),
    fromSourcePos,
    identLoc,
    Loc (Loc, locFileName, locLine, locColumn),
    dummyLoc,
    ParsedExpr,
    TypedExpr,
    ResolvedExpr,
    KExpr,
    ClosureExpr,
    Function (Function, funcName, isDirect, freeVars, boundedArgs, funcBody),
    ExprKind (..),
    Expr (..),
    getExprState,
    subst,
    visitExprM,
) where

import Control.Monad.Identity (Identity (runIdentity))
import Data.Kind (Type)
import Data.Text (Text, pack)
import Text.Megaparsec.Pos (SourcePos, sourceColumn, sourceLine, sourceName, unPos)
import Typing (Ty, TypeKind (TBool, TFloat, TInt, TUnit))

data Literal
    = LUnit
    | LBool Bool
    | LInt Int
    | LFloat Float
    deriving (Show, Eq, Ord)

getLiteralType :: Literal -> Ty
getLiteralType LUnit = TUnit
getLiteralType (LBool _) = TBool
getLiteralType (LInt _) = TInt
getLiteralType (LFloat _) = TFloat

data UnaryOp
    = Not
    | Neg
    | FNeg
    deriving (Show, Eq, Ord)

data RelationBinOp = Eq | Ne | Lt | Ge deriving (Show, Eq, Ord)
data IntBinOp = Add | Sub | Mul | Div deriving (Show, Eq, Ord)
data FloatBinOp = FAdd | FSub | FMul | FDiv deriving (Show, Eq, Ord)
data BinaryOp
    = RelationOp RelationBinOp
    | IntOp IntBinOp
    | FloatOp FloatBinOp
    deriving (Show, Eq, Ord)

data RawIdent
    = RawIdent Loc Text
    deriving (Show, Eq)

data Ident
    = -- | The entry of the program.
      Entry Loc
    | -- | An identifier after name resolution.
      UserDefined Loc Text
    | -- | An identifier generated by the compiler.
      CompilerGenerated Int
    | -- | An identifier that is used to refer to an external item.
      ExternalIdent Text
    deriving (Show, Eq, Ord)

identLoc :: Ident -> Loc
identLoc (Entry pos) = pos
identLoc (UserDefined pos _) = pos
identLoc (CompilerGenerated _) = Loc "generated" 0 0
identLoc (ExternalIdent _) = Loc "external" 0 0

-- | Pattern matching used in let-expressions.
data Pattern identTy
    = PUnit
    | PVar identTy
    | PRec identTy [identTy]
    | PTuple [identTy]
    deriving (Show, Eq, Ord)

-- | A condition of an if-expression.
data Cond operandTy (allowCompTy :: Bool) where
    CIdentity :: operandTy -> Cond operandTy allowCompTy
    CComp :: RelationBinOp -> operandTy -> operandTy -> Cond operandTy True

deriving instance
    (Show operandTy) =>
    Show (Cond operandTy a)
deriving instance
    (Eq operandTy) =>
    Eq (Cond operandTy a)

deriving instance
    (Ord operandTy) =>
    Ord (Cond operandTy a)

data Loc = Loc {locFileName :: Text, locLine :: Int, locColumn :: Int}
    deriving (Show, Eq, Ord)

fromSourcePos :: SourcePos -> Loc
fromSourcePos pos = Loc (pack (sourceName pos)) (unPos (sourceLine pos)) (unPos (sourceColumn pos))

dummyLoc :: Loc
dummyLoc = Loc "__dummy" 0 0

data TypedState = TypedState {getType :: Ty, getLoc :: Loc}
    deriving (Show, Eq, Ord)

data Function = Function
    { funcState :: TypedState
    , isDirect :: Bool
    , funcName :: Ident
    , freeVars :: [Ident]
    , boundedArgs :: [Ident]
    , funcBody :: ClosureExpr
    }
    deriving (Show, Eq)

-- | The type of an expression.
class ExprKind ty where
    type StateTy ty :: Type
    type IdentTy ty :: Type
    type OperandTy ty :: Type
    type ClosureTy ty :: Bool
    type BranchTy ty :: Bool

data ParsedExprKind

instance ExprKind ParsedExprKind where
    type StateTy ParsedExprKind = Loc
    type IdentTy ParsedExprKind = RawIdent
    type OperandTy ParsedExprKind = ParsedExpr
    type ClosureTy ParsedExprKind = False
    type BranchTy ParsedExprKind = False

{- | The type of an expression after parsing.
PGuard is used for avoiding invalid recursive type definition.
-}
type ParsedExpr = Expr ParsedExprKind

data ResolvedExprKind

instance ExprKind ResolvedExprKind where
    type StateTy ResolvedExprKind = Loc
    type IdentTy ResolvedExprKind = Ident
    type OperandTy ResolvedExprKind = ResolvedExpr
    type ClosureTy ResolvedExprKind = False
    type BranchTy ResolvedExprKind = False

{- | The type of an expression after name resolution.
RGuard is used for avoiding invalid recursive type definition.
-}
type ResolvedExpr = Expr ResolvedExprKind

data TypedExprKind

instance ExprKind TypedExprKind where
    type StateTy TypedExprKind = TypedState
    type IdentTy TypedExprKind = Ident
    type OperandTy TypedExprKind = TypedExpr
    type ClosureTy TypedExprKind = False
    type BranchTy TypedExprKind = False

-- | The type of an expression after type inference.
type TypedExpr = Expr TypedExprKind

data KExprKind

instance ExprKind KExprKind where
    type StateTy KExprKind = TypedState
    type IdentTy KExprKind = Ident
    type OperandTy KExprKind = Ident
    type ClosureTy KExprKind = False
    type BranchTy KExprKind = True

-- | The type of an expression after K-normalization.
type KExpr = Expr KExprKind

data ClosureExprKind

instance ExprKind ClosureExprKind where
    type StateTy ClosureExprKind = TypedState
    type IdentTy ClosureExprKind = Ident
    type OperandTy ClosureExprKind = Ident
    type ClosureTy ClosureExprKind = True
    type BranchTy ClosureExprKind = True

-- | The type of an expression after introducing closures.
type ClosureExpr = Expr ClosureExprKind

-- | An expression.
data Expr kind where
    Const ::
        StateTy kind ->
        Literal ->
        Expr kind
    Unary ::
        StateTy kind ->
        UnaryOp ->
        OperandTy kind ->
        Expr kind
    Binary ::
        StateTy kind ->
        BinaryOp ->
        OperandTy kind ->
        OperandTy kind ->
        Expr kind
    If ::
        StateTy kind ->
        Cond (OperandTy kind) (BranchTy kind) ->
        Expr kind ->
        Expr kind ->
        Expr kind
    Let ::
        StateTy kind ->
        Pattern (IdentTy kind) ->
        Expr kind ->
        Expr kind ->
        Expr kind
    Var ::
        StateTy kind ->
        IdentTy kind ->
        Expr kind
    App ::
        (ClosureTy kind ~ False) =>
        StateTy kind ->
        OperandTy kind ->
        [OperandTy kind] ->
        Expr kind
    Tuple ::
        StateTy kind ->
        [OperandTy kind] ->
        Expr kind
    ArrayCreate ::
        StateTy kind ->
        OperandTy kind ->
        OperandTy kind ->
        Expr kind
    Get ::
        StateTy kind ->
        OperandTy kind ->
        OperandTy kind ->
        Expr kind
    Put ::
        StateTy kind ->
        OperandTy kind ->
        OperandTy kind ->
        OperandTy kind ->
        Expr kind
    MakeClosure ::
        (ClosureTy kind ~ True) =>
        StateTy kind ->
        IdentTy kind ->
        [OperandTy kind] ->
        Expr kind
    ClosureApp ::
        (ClosureTy kind ~ True) =>
        StateTy kind ->
        IdentTy kind ->
        [OperandTy kind] ->
        Expr kind
    DirectApp ::
        (ClosureTy kind ~ True) =>
        StateTy kind ->
        IdentTy kind ->
        [OperandTy kind] ->
        Expr kind

deriving instance (Show (StateTy kind), Show (IdentTy kind), Show (OperandTy kind)) => Show (Expr kind)
deriving instance (Eq (StateTy kind), Eq (IdentTy kind), Eq (OperandTy kind)) => Eq (Expr kind)
deriving instance (Ord (StateTy kind), Ord (IdentTy kind), Ord (OperandTy kind)) => Ord (Expr kind)

getExprState :: Expr kind -> StateTy kind
getExprState (Const state _) = state
getExprState (Unary state _ _) = state
getExprState (Binary state _ _ _) = state
getExprState (If state _ _ _) = state
getExprState (Let state _ _ _) = state
getExprState (Var state _) = state
getExprState (App state _ _) = state
getExprState (Tuple state _) = state
getExprState (ArrayCreate state _ _) = state
getExprState (Get state _ _) = state
getExprState (Put state _ _ _) = state
getExprState (MakeClosure state _ _) = state
getExprState (ClosureApp state _ _) = state
getExprState (DirectApp state _ _) = state

-- | Substitute identifiers and operands. The identifiers should be unique.
subst ::
    (IdentTy kind ~ OperandTy kind, Eq (IdentTy kind)) =>
    IdentTy kind ->
    IdentTy kind ->
    Expr kind ->
    Expr kind
subst before after expr =
    runIdentity $
        visitExprM
            pure
            (\ident -> pure $ if ident == before then after else ident)
            (\operand -> pure $ if operand == before then after else operand)
            expr

visitExprM ::
    (Monad m, ClosureTy a ~ ClosureTy b, BranchTy a ~ BranchTy b) =>
    (StateTy a -> m (StateTy b)) ->
    (IdentTy a -> m (IdentTy b)) ->
    (OperandTy a -> m (OperandTy b)) ->
    Expr a ->
    m (Expr b)
visitExprM fState _ _ (Const state lit) = do
    state' <- fState state
    pure $ Const state' lit
visitExprM fState _ fOperand (Unary state op operand) = do
    state' <- fState state
    operand' <- fOperand operand
    pure $ Unary state' op operand'
visitExprM fState _ fOperand (Binary state op lhs rhs) = do
    state' <- fState state
    lhs' <- fOperand lhs
    rhs' <- fOperand rhs
    pure $ Binary state' op lhs' rhs'
visitExprM fState fIdent fOperand (If state (CIdentity cond) thenE elseE) = do
    state' <- fState state
    cond' <- fOperand cond
    thenE' <- visitExprM fState fIdent fOperand thenE
    elseE' <- visitExprM fState fIdent fOperand elseE
    pure $ If state' (CIdentity cond') thenE' elseE'
visitExprM fState fIdent fOperand (If state (CComp op lhs rhs) thenE elseE) = do
    state' <- fState state
    lhs' <- fOperand lhs
    rhs' <- fOperand rhs
    thenE' <- visitExprM fState fIdent fOperand thenE
    elseE' <- visitExprM fState fIdent fOperand elseE
    pure $ If state' (CComp op lhs' rhs') thenE' elseE'
visitExprM fState fIdent fOperand (Let state pat expr body) = do
    state' <- fState state
    expr' <- visitExprM fState fIdent fOperand expr
    body' <- visitExprM fState fIdent fOperand body
    pat' <- visitPatternM fIdent pat
    pure $ Let state' pat' expr' body'
  where
    visitPatternM :: (Monad m) => (identTy -> m identTy') -> Pattern identTy -> m (Pattern identTy')
    visitPatternM _ PUnit = pure PUnit
    visitPatternM fIdent' (PVar ident) = PVar <$> fIdent' ident
    visitPatternM fIdent' (PRec ident idents) = PRec <$> fIdent' ident <*> mapM fIdent' idents
    visitPatternM fIdent' (PTuple idents) = PTuple <$> mapM fIdent' idents
visitExprM fState fIdent _ (Var state ident) = do
    state' <- fState state
    ident' <- fIdent ident
    pure $ Var state' ident'
visitExprM fState _ fOperand (App state func args) = do
    state' <- fState state
    func' <- fOperand func
    args' <- mapM fOperand args
    pure $ App state' func' args'
visitExprM fState _ fOperand (Tuple state values) = do
    state' <- fState state
    values' <- mapM fOperand values
    pure $ Tuple state' values'
visitExprM fState _ fOperand (ArrayCreate state size value) = do
    state' <- fState state
    size' <- fOperand size
    value' <- fOperand value
    pure $ ArrayCreate state' size' value'
visitExprM fState _ fOperand (Get state array index) = do
    state' <- fState state
    array' <- fOperand array
    index' <- fOperand index
    pure $ Get state' array' index'
visitExprM fState _ fOperand (Put state array index value) = do
    state' <- fState state
    array' <- fOperand array
    index' <- fOperand index
    value' <- fOperand value
    pure $ Put state' array' index' value'
visitExprM fState fIdent fOperand (MakeClosure state ident args) = do
    state' <- fState state
    ident' <- fIdent ident
    args' <- mapM fOperand args
    pure $ MakeClosure state' ident' args'
visitExprM fState fIdent fOperand (ClosureApp state ident args) = do
    state' <- fState state
    ident' <- fIdent ident
    args' <- mapM fOperand args
    pure $ ClosureApp state' ident' args'
visitExprM fState fIdent fOperand (DirectApp state ident args) = do
    state' <- fState state
    ident' <- fIdent ident
    args' <- mapM fOperand args
    pure $ DirectApp state' ident' args'
